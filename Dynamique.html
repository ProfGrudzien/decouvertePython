<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="style.css"/>
    </head>
    <body>
        <div class="main">
            <h1>Programmation dynamique</h1>
            <h2>Retour sur le suite de Fibonacci</h2>
            <p>
                La suite de Fibonacci est d√©finie par :
                <ul>
                    <li>u<sub>0</sub> = 1</li>
                    <li>u<sub>1</sub> = 1</li>
                    <li>u<sub>n+2</sub> = u<sub>n+1</sub> + u<sub>n</sub>, pour tout entier naturel n</li>
                </ul>
            </p>
            Nous avons d√©j√† √©crit une fonction r√©cursive permettant de calculer u<sub>n</sub> :
            <div class="algo">
                <input type="button" class="copier" value="üìë" title="copier">
                <p class="code">
                    def fibo(n) : <br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n == 0 :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n == 1 :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;valeur = fibo(n-1) + fibo(n-2)<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;return valeur
                </p>
            </div>
            <p>
                Cette version r√©cursive de Fibonacci pr√©sente un gros inconv√©nient : des termes sont calcul√©s plusieurs fois, et le nombre d'appels r√©cursif et gigantesque. En stockant les r√©sultats d√©j√† calcul√©s, le nombre d'appels r√©cursifs chute drastiquement et la version r√©cursif est pertinente. Le stockage de ces appels r√©cursifs s'appelle la <mark>m√©mo√Øsation</mark> et cette fa√ßon de programmer s'appelle <mark>programmation dynamique</mark>. Voil√† une fonction r√©cursive dot√© de m√©mo√Øsation :
            </p>
            <div class="algo">
                <input type="button" class="copier" value="üìë" title="copier">
                <p class="code">
                    def fibo(n, M={}) : <br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;"""M est un dictionnaire servant √† la m√©mo√Øsation"""<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n in M :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return M[n]<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n == 0 :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n == 1 :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;valeur = fibo(n-1, M) + fibo(n-2, M)<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;M[n] = valeur<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;return valeur
                </p>
            </div>
            <p>Voici une version o√π le code est raccourci, le dictionnaire g√®re les conditions d‚Äôarr√™ts :</p>
            <div class="algo">
                <input type="button" class="copier" value="üìë" title="copier">
                <p class="code">
                    def fibo(n, M={0:1, 1:1}) : <br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;"""M est un dictionnaire servant √† la m√©mo√Øsation"""<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n not in M :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M[n] = fibo(n-1, M) + fibo(n-2, M)<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;return M[n]
                </p>
            </div>
            <p>
                La m√©mo√Øsation √©tant facilement g√©n√©ralisable, des outils ont √©t√© d√©velopp√©es en Python pour simplifier son utilisation.
                Le module <mark class="code">functools</mark> propose d'ajouter le d√©corateur <mark class="code">lru_cache</mark> la ligne au dessus de la d√©claration de la fonction r√©cursive.
                Exemple :
            </p>
            <div class="algo">
                <input type="button" class="copier" value="üìë" title="copier">
                <p class="code">
                    from functools import lru_cache<br/>&nbsp;<br/>
                    @lru_cache()<br/>
                    def fibo(n) : <br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n == 0 :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;if n == 1 :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;valeur = fibo(n-1) + fibo(n-2)<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;return valeur
                </p>
            </div>
            <h2>Nombre premier</h2>
            <p>
                La programmation dynamique n'est pas r√©serv√©e aux fonctions r√©cursives.
                Par exemple, un algorithme efficace pour d√©terminer si un nombre est premier ou non est bas√©e sur le crible d‚Äô√âratosth√®ne.
                Le crible est mis √† jour si besoin lors de la recherche de nombre premier plus grand que la longueur du crible.
                Voil√† un exemple d'impl√©mentation :
            <div class="algo">
                <input type="button" class="copier" value="üìë" title="copier">
                <p class="code">
                    class Crible() :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;def __init__(self) :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.dictionnaire = {1:False}<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.longueur = 1<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;def remplir(self, n) :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(self.longueur+1, n+1) :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.dictionnaire[i] = True<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(2, n) :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if self.dictionnaire[i] :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for j in range((i)*(1+self.longueur//i), n+1, i) :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.dictionnaire[j] = False<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.longueur = n<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;def est_premier(self, n) :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if n > self.longueur :<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.remplir(n)<br/>
                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return self.dictionnaire[n]<br/>&nbsp;<br/>
                    C = Crible()<br/>
                    print(C.est_premier(2))<br/>
                    print(C.est_premier(3))<br/>
                    print(C.est_premier(4))<br/>
                    print(C.est_premier(999983))<br/>
                    print(C.est_premier(999983))<br/>
                </p>
            </div>
            <div class="exercice">
                <ol>
                    <li>Dans l'impl√©mentation propos√©e ci-dessus, que ce qui permet la m√©mo√Øsation ?</li>
                    <li>Comment cela est-il visible lors des appels √† la m√©thode <mark class="code">C.est_premier</mark> ?</li>
                </ol>
            </div>
            </p>
            <h2>Alignement de s√©quence</h2>
            <p>
                Une s√©quence est une suite finie de symboles choisis dans un alphabet d√©termin√©.
                Cet alphabet peut par exemple √™tre :
                <ul>
                    <li>de a √† z pour du texte</li>
                    <li>0 ou 1 pour des s√©quences en binaire</li>
                    <li>de 0 √† 9 pour des s√©quences num√©riques</li>
                    <li>A, T, C, G pour des s√©quences ADN</li>
                </ul>
                Pour la suite de ce cours, nous nous placerons dans l'alphabet A, T, C, G.
            </p>
            <p>
                L'objectif de l'alignement de s√©quence est de comparer deux s√©quences donn√©es pour d√©terminer leur ressemblance.<br/>
                Dans la pratique, les s√©quences ADN sont extraite de l'ADN complet et ne commencent pas au m√™me endroit.
                De plus, suite √† des erreurs d'√©criture ou √† des mutations diverses, les s√©quences ne sont pas identiques.
            </p>
            <p>
                Nous allons ajouter √† l'alphabet le nouveau caract√®re <mark class="code">-</mark> (trou). Il permettra d'√©tudier le d√©calage d'une s√©quence par rapport √† l'autre.
            </p>
            <div class="exercice">
                <ol>
                    <li>Ecrire une fonction <mark class="code">comparer_lettres(a, b)</mark> retournant :
                        <ul>
                            <li>6 si les deux lettres sont identiques (et ne sont pas des trous)</li>
                            <li>-3 si une des lettres est un trou</li>
                            <li>-1 si les deux lettres sont diff√©rentes (et ne sont pas des trous)</li>
                        </ul>
                        Cette fonction nous permettra d'√©tablir un score permettant de comparer les alignements.
                    </li>
                    <li>
                        On note <mark class="code">a</mark> la premi√®re lettre de la s√©quence A et <mark class="code">b</mark> la premi√®re lettre de la s√©quence B. Alors le meilleur alignement possible v√©rifier l'une des observations suivantes :
                        <ul>
                            <li>les lettres <mark class="code">a</mark> et <mark class="code">b</mark> sont align√©es</li>
                            <li>la lettre <mark class="code">a</mark> est align√©e avec un trou</li>
                            <li>la lettre <mark class="code">b</mark> est align√©e avec un trou</li>
                        </ul>
                        Ecrire une fonction r√©cursive <mark class="code">meilleur_alignement(A, B)</mark> retournant une liste contenant les 3 informations :
                        <ul>
                            <li>le score du meilleur alignement calcul√© gr√¢ce √† comparer_lettres(a, b)</li>
                            <li>la s√©quence A √† laquelle sont ajout√©s les trous pour obtenir ce meilleur alignement</li>
                            <li>la s√©quence B √† laquelle sont ajout√©s les trous pour obtenir ce meilleur alignement</li>
                        </ul>
                    </li>
                    <li>Tester cette fonction avec les s√©quences <mark class="code">ATATCCGGA</mark> et <mark class="code">ATCCGGAAT</mark>.</li>
                    <li>Modifier le programme pour ajouter de la m√©mo√Øsation.</li>
                    <li>Tester de nouveau la fonction avec les s√©quences <mark class="code">ATATCCGGA</mark> et <mark class="code">ATCCGGAAT</mark>.</li>
                </ol>
            </div>
        </div>
        <script type="text/javascript" src="script.js"></script>
    </body>
</html>

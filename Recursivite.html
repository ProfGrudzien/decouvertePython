<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="style.css"/>
        <link rel="stylesheet" href="recursivite.css"/>
    </head>
    <body>
        <div class="main">
            <h1>R√©cursivit√©</h1>
            <p>
                Dans cette activit√©, nous allons d√©couvrir le principe de la r√©cursivit√©.
            </p>
            <h2>Retour sur un exercice pr√©c√©dent</h2>
            <div class="exercice">
                Ecrire une fonction qui demande un identifiant √† l'utilisateur.
                Cette fonction doit redemander un identifiant jusqu'√† ce que l'utilisateur donne un identifiant non vide (diff√©rent de <mark class="code">""</mark>)
            </div>
            <p>
                Cette fonction est constuite sur la logique suivante : demander un identifiant tant que l'identifiant donn√© par l'utilisateur est vide.
            </p>
            <p>
                On peut adopter une autre logique : demander un identifiant √† l'utilisateur puis, s'il est vide, demander √† nouveau un identifiant √† l'utilisateur.
            </p>
            <div class="exercice">
                Compl√©ter la fonction suivante :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def demander_identifiant() : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;identifiant = input("Quel est votre identifiant ? ") <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if identifiant != "" :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ...<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Erreur de saisie.")<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ...<br/>
                    </p>
                </div>
            </div>
            <h2>D√©finition</h2>
            <p>
                Une fonction est r√©cursive si elle se d√©finit √† partir d'elle-m√™me. Par exemple, une fonction qui comporte, dans son corps, au moins un appel √† elle-m√™me est une fonction r√©cursive.
            </p>
            <p>
                Les fonctions bas√©es sur une simple boucle <mark class="code">while</mark> peuvent tr√®s facilement √™tre traduite en fonction r√©cursive. Exemple :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def nombre_bits(n) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Retourne le nombre de bits n√©cessaire pour coder un entier naturel en binaire.<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;n : le nombre entier naturel √©crit en base 10.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;assert n >= 0, 'Cette fonction attend un entier positif ou nul'<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;compteur = 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;while n > 1 : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = n // 2<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compteur = compteur + 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;return compteur<br/>
                    </p>
                </div>
                Se traduit de mani√®re r√©cursive en :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def nombre_bits(n) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Retourne le nombre de bits n√©cessaire pour coder un entier naturel en binaire.<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;n : le nombre entier naturel √©crit en base 10.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;assert n >= 0, 'Cette fonction attend un entier positif ou nul'<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if n > 1 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1 + nombre_bits(n//2)<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    </p>
                </div>
            </p>
            <p>
            Tout comme lorsque l'on √©crit des boucles <mark class="code">while</mark>, il faut √™tre tr√®s vigilent sur la condition d'arr√™t d'une fonction r√©cursive. Lorsque ces conditions sont mal √©crites, le message d'erreur <mark class="code">'maximum recursion depth exceeded'</mark> appara√Æt.
            </p>
            <img src="images/Gru.jpg">
            <div class="exercice">
                Ecrire une fonction qui √©num√®rent les √©l√©ments d'une liste, c'est-√†-dire qui retourne une cha√Æne de caract√®re compos√©e des √©l√©ments s√©par√©s par une virgule ou par un ¬´ et ¬ª et termine l'√©num√©ration par un point.<br/>Exemple :<br/><mark class="code">enumeration(["p√™che", "pomme", "poire", "abricot"])</mark><br/>donne :<br/><mark class="code">"p√™che, pomme, poire et abricot."</mark>
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui retourne le plus grand √©l√©ment d'une liste de nombres entiers.
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui v√©rifie si une cha√Æne de caract√®res est un palindrome (identique en la lisant de la droite vers la gauche ou de la gauche vers la droite).<br/>
                La fonction sera alors test√©e avec les cha√Ænes de caract√®res :
                <ul>
                    <li>EMMA</li>
                    <li>ANNA</li>
                    <li>cano√´</li>
                    <li>kayak</li>
                    <li>engage le jeu que je le gagne</li>
                </ul>
                Pour aller plus loin :<br>
                Modifier cette fonction pour qu'elle ignore les espaces.
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui v√©rifie si deux cha√Ænes de caract√®res sont des anagrammes (compos√©es des m√™mes lettres).<br/>
                Cette fonction peut faire appel √† la fonction <mark class="code">premier_indice</mark> suivante :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def premier_indice(liste, valeur, offset=0) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Si `valeur` est dans la liste `liste`, retourne le premier indice o√π l'on trouve cette valeur. Sinon, retourne -1<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;liste&nbsp;  : la liste o√π l'on cherche une valeur.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;valeur : la valeur que l'on cherche dans la liste.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;offset : le nombre de valeurs d√©j√† √©cart√©es par r√©currence.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if len(liste) == 0 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;elif liste[0] == valeur :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return offset<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return premier_indice(liste[1:], valeur, offset+1)<br/>
                    </p>
                </div>
            </div>
            <h2>Pile des appels r√©cursifs</h2>
            <p>
                Le premier appel de la fonction r√©cursifs doit attendre le r√©sultat des autres appels r√©cursifs.
                Pour cela, les appels sont stock√©s dans une ¬´&nbsp;pile d'ex√©cution&nbsp;¬ª. Les piles sont des structures algorithmiques qui seront √©tudi√©s en d√©tails plus tard dans l'ann√©e.
            </p>
            <p>
                Dans la pratique, ces piles ne sont pas de tailles infinies. L'√©criture d'une fonction r√©cursive sans prendre de pr√©caution peut mener √† remplir cette pile est entra√Æne un d√©passement de m√©moire. C'est la raison du message <mark class="code">'maximum recursion depth exceeded'</mark>.
            </p>
            <p>
                Voici une illustration de la pile d'appels r√©cursifs lorsque l'on utilise la fonction r√©cursive <mark class="code">maximum</mark> de l'exercice 4 (plus grand √©l√©ment d'une liste) sur la liste <mark class="code">[10, 8, 4, 9, 7]</mark>
            </p>
            <div class="algo" id="pile">
                <p class="code" id="lvl5">maximum([7])</p>
                <p class="code" id="lvl4">maximum([9, 7])</p>
                <p class="code" id="lvl3">maximum([4, 9, 7])</p>
                <p class="code" id="lvl2">maximum([8, 4, 9, 7])</p>
                <p class="code" id="lvl1">maximum([10, 8, 4, 9, 7])</p>
            </div>
            <div align="center">
                <input type="button" value="<" id="prev"></input>
                <input type="button" value=">" id="next"></input>
            </div>
            <script type="text/javascript" src="recursivite.js"></script>
            <div class="exercice">
                Ecrire la pile d'ex√©cution lors lors de l'appel de <mark class="code">est_palydrome("kayak")</mark> (exercice 5).
            </div>
            <h2>Applications</h2>
            <h3>Recherche dichotomique</h3>
            <h3>Rendu du monnaie</h3>
            <h3>Suite de Fibonacci</h3>
            <h3>Tour de Hano√Ø</h3>
        </div>
        <script type="text/javascript" src="script.js"></script>
    </body>
</html>

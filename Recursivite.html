<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="style.css"/>
        <link rel="stylesheet" href="recursivite.css"/>
    </head>
    <body>
        <div class="main">
            <h1>R√©cursivit√©</h1>
            <p>
                Dans cette activit√©, nous allons d√©couvrir le principe de la r√©cursivit√©.
            </p>
            <h2>Retour sur un exercice pr√©c√©dent</h2>
            <div class="exercice">
                Ecrire une fonction qui demande un identifiant √† l'utilisateur.
                Cette fonction doit redemander un identifiant jusqu'√† ce que l'utilisateur donne un identifiant non vide (diff√©rent de <mark class="code">""</mark>)
            </div>
            <p>
                Cette fonction est constuite sur la logique suivante : demander un identifiant tant que l'identifiant donn√© par l'utilisateur est vide.
            </p>
            <p>
                On peut adopter une autre logique : demander un identifiant √† l'utilisateur puis, s'il est vide, demander √† nouveau un identifiant √† l'utilisateur.
            </p>
            <div class="exercice">
                Compl√©ter la fonction suivante :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def demander_identifiant() : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;identifiant = input("Quel est votre identifiant ? ") <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if identifiant != "" :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ...<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Erreur de saisie.")<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ...<br/>
                    </p>
                </div>
            </div>
            <h2>D√©finition</h2>
            <p>
                Une fonction est r√©cursive si elle se d√©finit √† partir d'elle-m√™me. Par exemple, une fonction qui comporte, dans son corps, au moins un appel √† elle-m√™me est une fonction r√©cursive.
            </p>
            <p>
                Les fonctions bas√©es sur une simple boucle <mark class="code">while</mark> peuvent tr√®s facilement √™tre traduite en fonction r√©cursive. Exemple :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def nombre_bits(n) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Retourne le nombre de bits n√©cessaire pour coder un entier naturel en binaire.<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;n : le nombre entier naturel √©crit en base 10.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;assert n >= 0, 'Cette fonction attend un entier positif ou nul'<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;compteur = 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;while n > 1 : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = n // 2<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compteur = compteur + 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;return compteur<br/>
                    </p>
                </div>
                Se traduit de mani√®re r√©cursive en :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def nombre_bits(n) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Retourne le nombre de bits n√©cessaire pour coder un entier naturel en binaire.<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;n : le nombre entier naturel √©crit en base 10.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;assert n >= 0, 'Cette fonction attend un entier positif ou nul'<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if n > 1 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1 + nombre_bits(n//2)<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    </p>
                </div>
            </p>
            <p>
            Tout comme lorsque l'on √©crit des boucles <mark class="code">while</mark>, il faut √™tre tr√®s vigilent sur la condition d'arr√™t d'une fonction r√©cursive. Lorsque ces conditions sont mal √©crites, le message d'erreur <mark class="code">'maximum recursion depth exceeded'</mark> appara√Æt.
            </p>
            <img src="images/Gru.jpg">
            <div class="exercice">
                Ecrire une fonction qui √©num√®rent les √©l√©ments d'une liste, c'est-√†-dire qui retourne une cha√Æne de caract√®re compos√©e des √©l√©ments s√©par√©s par une virgule ou par un ¬´ et ¬ª et termine l'√©num√©ration par un point.<br/>Exemple :<br/><mark class="code">enumeration(["p√™che", "pomme", "poire", "abricot"])</mark><br/>donne :<br/><mark class="code">"p√™che, pomme, poire et abricot."</mark>
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui retourne le plus grand √©l√©ment d'une liste de nombres entiers.
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui v√©rifie si une cha√Æne de caract√®res est un palindrome (identique en la lisant de la droite vers la gauche ou de la gauche vers la droite).<br/>
                La fonction sera alors test√©e avec les cha√Ænes de caract√®res :
                <ul>
                    <li>EMMA</li>
                    <li>ANNA</li>
                    <li>cano√´</li>
                    <li>kayak</li>
                    <li>azfghza</li>
                    <li>engage le jeu que je le gagne</li>
                </ul>
                Pour aller plus loin :<br>
                Modifier cette fonction pour qu'elle ignore les espaces.
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui v√©rifie si deux cha√Ænes de caract√®res sont des anagrammes (compos√©es des m√™mes lettres).<br/>
                Cette fonction peut faire appel √† la fonction <mark class="code">premier_indice</mark> suivante :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def premier_indice(liste, valeur, offset=0) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Si `valeur` est dans la liste `liste`, retourne le premier indice o√π l'on trouve cette valeur. Sinon, retourne -1<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;liste&nbsp;  : la liste o√π l'on cherche une valeur.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;valeur : la valeur que l'on cherche dans la liste.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;offset : le nombre de valeurs d√©j√† √©cart√©es par r√©currence.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if len(liste) == 0 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;elif liste[0] == valeur :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return offset<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return premier_indice(liste[1:], valeur, offset+1)<br/>
                    </p>
                </div>
            </div>
            <h2>Pile des appels r√©cursifs</h2>
            <p>
                Le premier appel de la fonction r√©cursifs doit attendre le r√©sultat des autres appels r√©cursifs.
                Pour cela, les appels sont stock√©s dans une ¬´&nbsp;pile d'ex√©cution&nbsp;¬ª. Les piles sont des structures algorithmiques qui seront √©tudi√©s en d√©tails plus tard dans l'ann√©e.
            </p>
            <p>
                Dans la pratique, ces piles ne sont pas de tailles infinies. L'√©criture d'une fonction r√©cursive sans prendre de pr√©caution peut mener √† remplir cette pile est entra√Æne un d√©passement de m√©moire. C'est la raison du message <mark class="code">'maximum recursion depth exceeded'</mark>.
            </p>
            <p>
                Voici une illustration de la pile d'appels r√©cursifs lorsque l'on utilise la fonction r√©cursive <mark class="code">maximum</mark> de l'exercice 4 (plus grand √©l√©ment d'une liste) sur la liste <mark class="code">[10, 8, 4, 9, 7]</mark>
            </p>
            <div class="algo" id="pile">
                <p class="code" id="lvl5">maximum([7])</p>
                <p class="code" id="lvl4">maximum([9, 7])</p>
                <p class="code" id="lvl3">maximum([4, 9, 7])</p>
                <p class="code" id="lvl2">maximum([8, 4, 9, 7])</p>
                <p class="code" id="lvl1">maximum([10, 8, 4, 9, 7])</p>
            </div>
            <div align="center">
                <input type="button" value="<" id="prev" class="navigation"></input>
                <input type="button" value=">" id="next" class="navigation"></input>
            </div>
            <script type="text/javascript" src="recursivite.js"></script>
            <div class="exercice">
                Ecrire la pile d'ex√©cution lors lors de l'appel de <mark class="code">est_palydrome("kayak")</mark> (exercice 5).
            </div>
            <h2>Applications</h2>
            <h3>Recherche dichotomique</h3>
            <p>
                La recherche dichotomique est un algorithme de recherche d'une valeur dans une liste <mark>tri√©e</mark> vu en premi√®re.<br/>
                Nous allons voir ici une programmation r√©cursive de la recherche dichotomique.
            </p>
            <p>
                Le principe de la recherche dichotomique consiste √† comparer la valeur recherch√©e avec la valeur centrale de la liste afin d'√©liminer la moiti√© des valeurs o√π ne peut pas se trouver la valeur recherch√©e.
            </p>
            <div class="exercice">
                <ol>
                    <li>Dans une liste de <mark class="code">n</mark> √©l√©ments, quel est l'indice de l'√©l√©ment central ?</li>
                    <li>Si la valeur recherch√©e est plus grande que la valeur centrale, quelle partie de la liste faut-il √©liminer ?</li>
                    <li>Quelle est la condition d'arr√™t de la r√©cursivit√© ?</li>
                    <li>Ecrire la pile d'ex√©cution lors de l'appel de : <br/> <mark class="code">recherche_dichotomique([12, 13, 15, 17, 21, 22, 22], 15)</mark></li>
                    <li>Ecrire la pile d'ex√©cution lors de l'appel de : <br/> <mark class="code">recherche_dichotomique([0, 1, 1, 2, 3, 5, 8, 13, 21], 7)</mark></li>
                    <li>Programmer la recherche dichotomique de mani√®re r√©cursive.</li>
                </ol>
            </div>
            <h3>Rendu du monnaie</h3>
            <p>
                En classe de premi√®re, nous avons vu un algorithme de rendu de monnaie.
                Cet algorithme √©tait dit <mark>glouton</mark> car il √©tait bas√© sur des choix qui paraissaient optimaux √† chaque √©tape, mais ne garantissait pas que le r√©sultat global √©tait optimal.
                Une solution pour trouver le rendu optimal serai de d√©terminer toutes les solutions de rendu de monnaie possible.
            </p>
            <p>
                Nous allons √©crire un algorithme r√©cursif qui permet de dresser cette liste.<br/>
                On suppose que le montant √† rendre et un nombre entier, tout comme le montant des pi√®ces et des billets.<br/>
                On suppose √©galement que l'on dispose de toutes les pi√®ces et billets en quantit√© illimit√©e.<br/>
                La liste des pi√®ces et billets disponibles est : <mark class="code">[500, 200, 100, 50, 20, 10, 5, 2, 1]</mark><br/>
                Par la suite, on parlera uniquement de pi√®ces pour simplifier les explications.
            </p>
            <p>
                Le principe est le suivant :
                <ul>
                    <li>
                        si le montant est sup√©rieur ou √©gal √† la valeur de la premi√®re pi√®ce, alors deux choix s'offrent √† moi :
                        <ul>
                            <li>j'utilise cette pi√®ce et je cherche √† rendre une montant plus petit avec les m√™mes pi√®ces disponibles.</li>
                            <li>je n'utilise pas cette pi√®ce et je cherche √† rendre le m√™me montant avec les autres pi√®ces disponibles.</li>
                        </ul>
                    </li>
                    <li>si le montant est inf√©rieur √† la valeur de la premi√®re pi√®ce, alors je cherche √† rendre le m√™me montant avec les autres pi√®ces disponibles.</li>
                </ul>
            </p>
            <div class="exercice">
                <ol>
                    <li>Quelles sont les conditions d'arr√™ts ?</li>
                    <li>Parmi les conditions d'arr√™ts, laquelle aboutit √† un rendu de monnaie possible ?</li>
                    <li>Ecrire la pile d'ex√©cution pour rendre 6 euros avec la liste de pi√®ces et de billets disponibles ci-dessus.</li>
                    <li>Programmer de mani√®re r√©cursive le programme affichant les rendus de monnaie possible.</li>
                </ol>
            </div>
            <h3>Suite de Fibonacci</h3>
                <p>
                    La suite de Fibonacci est d√©finie par :
                    <ul>
                        <li>u<sub>0</sub> = 1</li>
                        <li>u<sub>1</sub> = 1</li>
                        <li>u<sub>n+2</sub> = u<sub>n+1</sub> + u<sub>n</sub>, pour tout entier naturel n</li>
                    </ul>
                </p>
                <div class="exercice">
                    <ol>
                        <li>Programmer de mani√®re r√©cursive la fonction <mark class="code">fibo(n)</mark> donnant la valeur de u<sub>n</sub></li>
                        <li>Ecrire la pile d'ex√©cution lors de l'appel de <mark class="code">fibo(4)</mark></li>
                    </ol>
                </div>
                <p>
                    La r√©cursivit√© sur la suite de Fibonacci pose vite des probl√®mes ! Le nombre d'appels r√©cursifs devient vite impressionnant ! Cependant cette fonction peut √™tre optimis√©e car beaucoup de ces appels sont identiques. Ces r√©sultats pourraient √™tre stock√©s lors du premier calcul pour √™tre r√©utilis√© lors de autres appels. Cela s'appelle la <mark>m√©mo√Øsation</mark> et cette nouvelle approche s'appelle <mark>programmation dynamique</mark>.
                </p>
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def fibo(n, M={}) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""M est un dictionnaire servant √† la m√©mo√Øsation"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if n in M :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return M[n]<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if n == 0 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if n == 1 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;valeur = fibo(n-1, M) + fibo(n-2, M)<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;M[n] = valeur<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;return valeur
                    </p>
                </div>
            <h3>Tour de Hano√Ø</h3>
                <p>
                    Les <a href="https://fr.wikipedia.org/wiki/Tours_de_Hano%C3%AF">Tours de Hano√Ø</a> sont un jeu de r√©flexion ou le but est de d√©placer une tour form√©e de disque d'un pilier vers un autre en utilisant un troisi√®me pilier interm√©diaire. A tout moment, il est impossible de d√©poser un disque sur un disque de rayon plus petit.
                    <img src="images/hanoi.jpg"/>
                    <div class="exercice">
                        <ol>
                            <li>Avec combien de disque ce probl√®me est-il √©vident ?</li>
                            <li>Expliquer comment r√©soudre le probl√®me √† 3 disques en utilisant la r√©solution du probl√®me √† 2 disques et du probl√®me √† 1 disque.</li>
                            <li>Expliquer comment r√©soudre le probl√®me √† 4 disques en utilisant la r√©solution du probl√®me √† 3 disques et du probl√®me √† 1 disque.</li>
                            <li>
                                Ecrire une fonction <mark class="code">hanoi(depart, arrive, intermediaire)</mark> affichant toutes les √©tapes pour r√©soudre le d√©placement de la tour <mark class="code">depart</mark> vers la tour <mark class="code">arrive</mark> en utilisant la tour <mark class="code">intermediaire</mark>.<br/>
                                Les tours sont des listes dont la premi√®re valeur est le nom du pilier puis les autres sont les entiers repr√©sentants les rayons des disques plac√©es dans cette tour.<br/>
                                Pour r√©soudre le probl√®me de la tour de Hano√Ø √† 8 disques, nous appellerons <mark class="code">hanoi(["A", 8, 7, 6, 5, 4, 3, 2, 1], ["C"], ["B"])</mark><br/>
                                Vous pourrez utiliser la fonction <mark class="code">affichage_hanoi.py</mark> pour afficher les √©tapes interm√©diaires.
                            </li>
                        </ol>
                    </div>
                    <div class="algo">
                        <input type="button" class="copier" value="üìë" title="copier">
                        <p class="code">
                            def affichage_hanoi(tour1, tour2, tour3) :<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;tours = sorted([tour1, tour2, tour3])<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;rayon_max = max(tour1[1:] + tour2[1:] + tour3[1:])<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;hauteur = len(tour1) + len(tour2) + len(tour3)<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;longueur = 6*rayon_max + 9<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;centres = [rayon_max+1, 3*rayon_max+4, 5*rayon_max+7]<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;G = [[" " for j in range(longueur)] for i in range(hauteur)]<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;for j in range(longueur) :<br/>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G[0][j] = "‚ñá"<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;for t in range(3) :<br/>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(hauteur) :<br/>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G[i][centres[t]] = "‚îÇ"<br/>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G[0][centres[t]] = "‚ñá"<br/>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for i in range(1, len(tours[t])) :<br/>
                                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for k in range(tours[t][i]+1) :<br/>
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G[i][centres[t]-k] = "‚ñá"<br/>
                                            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;G[i][centres[t]+k] = "‚ñá"<br/>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("")<br/>
                                &nbsp;&nbsp;&nbsp;&nbsp;for i in range(hauteur-1, -1, -1) :<br/>
                                    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print(''.join(G[i]))<br/>

                        </p>
                    </div>
                </p>
            <h2>Autres exercices</h2>
            <ol>
                <li><a href="miroir.html">miroir d'un mot</a></li>
                <li><a href="syracuse.html">suite de Syracuse</a></li>
                <li><a href="coefficientsBinomiaux.html">coefficients binomiaux</a></li>
                <li><a href="permutations.html">liste des permutations (et anagrammes)</a></li>
                <li><a href="jeuDame.html">jeu de la dame</a></li>
            </ol>
        </div>
        <script type="text/javascript" src="script.js"></script>
    </body>
</html>

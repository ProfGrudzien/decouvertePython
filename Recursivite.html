<!DOCTYPE html>
<html lang="fr">
    <head>
        <meta charset="utf-8"/>
        <link rel="stylesheet" href="style.css"/>
        <link rel="stylesheet" href="recursivite.css"/>
    </head>
    <body>
        <div class="main">
            <h1>R√©cursivit√©</h1>
            <p>
                Dans cette activit√©, nous allons d√©couvrir le principe de la r√©cursivit√©.
            </p>
            <h2>Retour sur un exercice pr√©c√©dent</h2>
            <div class="exercice">
                Ecrire une fonction qui demande un identifiant √† l'utilisateur.
                Cette fonction doit redemander un identifiant jusqu'√† ce que l'utilisateur donne un identifiant non vide (diff√©rent de <mark class="code">""</mark>)
            </div>
            <p>
                Cette fonction est constuite sur la logique suivante : demander un identifiant tant que l'identifiant donn√© par l'utilisateur est vide.
            </p>
            <p>
                On peut adopter une autre logique : demander un identifiant √† l'utilisateur puis, s'il est vide, demander √† nouveau un identifiant √† l'utilisateur.
            </p>
            <div class="exercice">
                Compl√©ter la fonction suivante :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def demander_identifiant() : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;identifiant = input("Quel est votre identifiant ? ") <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if identifiant != "" :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ...<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print("Erreur de saisie.")<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return ...<br/>
                    </p>
                </div>
            </div>
            <h2>D√©finition</h2>
            <p>
                Une fonction est r√©cursive si elle se d√©finit √† partir d'elle-m√™me. Par exemple, une fonction qui comporte, dans son corps, au moins un appel √† elle-m√™me est une fonction r√©cursive.
            </p>
            <p>
                Les fonctions bas√©es sur une simple boucle <mark class="code">while</mark> peuvent tr√®s facilement √™tre traduite en fonction r√©cursive. Exemple :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def nombre_bits(n) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Retourne le nombre de bits n√©cessaire pour coder un entier naturel en binaire.<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;n : le nombre entier naturel √©crit en base 10.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;assert n >= 0, 'Cette fonction attend un entier positif ou nul'<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;compteur = 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;while n > 1 : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;n = n // 2<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;compteur = compteur + 1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;return compteur<br/>
                    </p>
                </div>
                Se traduit de mani√®re r√©cursive en :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def nombre_bits(n) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Retourne le nombre de bits n√©cessaire pour coder un entier naturel en binaire.<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;n : le nombre entier naturel √©crit en base 10.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;assert n >= 0, 'Cette fonction attend un entier positif ou nul'<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if n > 1 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1 + nombre_bits(n//2)<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return 1<br/>
                    </p>
                </div>
            </p>
            <p>
            Tout comme lorsque l'on √©crit des boucles <mark class="code">while</mark>, il faut √™tre tr√®s vigilent sur la condition d'arr√™t d'une fonction r√©cursive. Lorsque ces conditions sont mal √©crites, le message d'erreur <mark class="code">'maximum recursion depth exceeded'</mark> appara√Æt.
            </p>
            <img src="images/Gru.jpg">
            <div class="exercice">
                Ecrire une fonction qui √©num√®rent les √©l√©ments d'une liste, c'est-√†-dire qui retourne une cha√Æne de caract√®re compos√©e des √©l√©ments s√©par√©s par une virgule ou par un ¬´ et ¬ª et termine l'√©num√©ration par un point.<br/>Exemple :<br/><mark class="code">enumeration(["p√™che", "pomme", "poire", "abricot"])</mark><br/>donne :<br/><mark class="code">"p√™che, pomme, poire et abricot."</mark>
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui retourne le plus grand √©l√©ment d'une liste de nombres entiers.
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui v√©rifie si une cha√Æne de caract√®res est un palindrome (identique en la lisant de la droite vers la gauche ou de la gauche vers la droite).<br/>
                La fonction sera alors test√©e avec les cha√Ænes de caract√®res :
                <ul>
                    <li>EMMA</li>
                    <li>ANNA</li>
                    <li>cano√´</li>
                    <li>kayak</li>
                    <li>azfghza</li>
                    <li>engage le jeu que je le gagne</li>
                </ul>
                Pour aller plus loin :<br>
                Modifier cette fonction pour qu'elle ignore les espaces.
            </div>
            <div class="exercice">
                Ecrire une fonction r√©cursive qui v√©rifie si deux cha√Ænes de caract√®res sont des anagrammes (compos√©es des m√™mes lettres).<br/>
                Cette fonction peut faire appel √† la fonction <mark class="code">premier_indice</mark> suivante :
                <div class="algo">
                    <input type="button" class="copier" value="üìë" title="copier">
                    <p class="code">
                        def premier_indice(liste, valeur, offset=0) : <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;""" Si `valeur` est dans la liste `liste`, retourne le premier indice o√π l'on trouve cette valeur. Sinon, retourne -1<br/>
                        <br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;liste&nbsp;  : la liste o√π l'on cherche une valeur.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;valeur : la valeur que l'on cherche dans la liste.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;offset : le nombre de valeurs d√©j√† √©cart√©es par r√©currence.<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;"""<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;if len(liste) == 0 :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return -1<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;elif liste[0] == valeur :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return offset<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;else :<br/>
                        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return premier_indice(liste[1:], valeur, offset+1)<br/>
                    </p>
                </div>
            </div>
            <h2>Pile des appels r√©cursifs</h2>
            <p>
                Le premier appel de la fonction r√©cursifs doit attendre le r√©sultat des autres appels r√©cursifs.
                Pour cela, les appels sont stock√©s dans une ¬´&nbsp;pile d'ex√©cution&nbsp;¬ª. Les piles sont des structures algorithmiques qui seront √©tudi√©s en d√©tails plus tard dans l'ann√©e.
            </p>
            <p>
                Dans la pratique, ces piles ne sont pas de tailles infinies. L'√©criture d'une fonction r√©cursive sans prendre de pr√©caution peut mener √† remplir cette pile est entra√Æne un d√©passement de m√©moire. C'est la raison du message <mark class="code">'maximum recursion depth exceeded'</mark>.
            </p>
            <p>
                Voici une illustration de la pile d'appels r√©cursifs lorsque l'on utilise la fonction r√©cursive <mark class="code">maximum</mark> de l'exercice 4 (plus grand √©l√©ment d'une liste) sur la liste <mark class="code">[10, 8, 4, 9, 7]</mark>
            </p>
            <div class="algo" id="pile">
                <p class="code" id="lvl5">maximum([7])</p>
                <p class="code" id="lvl4">maximum([9, 7])</p>
                <p class="code" id="lvl3">maximum([4, 9, 7])</p>
                <p class="code" id="lvl2">maximum([8, 4, 9, 7])</p>
                <p class="code" id="lvl1">maximum([10, 8, 4, 9, 7])</p>
            </div>
            <div align="center">
                <input type="button" value="<" id="prev" class="navigation"></input>
                <input type="button" value=">" id="next" class="navigation"></input>
            </div>
            <script type="text/javascript" src="recursivite.js"></script>
            <div class="exercice">
                Ecrire la pile d'ex√©cution lors lors de l'appel de <mark class="code">est_palydrome("kayak")</mark> (exercice 5).
            </div>
            <h2>Applications</h2>
            <h3>Recherche dichotomique</h3>
            <p>
                La recherche dichotomique est un algorithme de recherche d'une valeur dans une liste <mark>tri√©e</mark> vu en premi√®re.<br/>
                Nous allons voir ici une programmation r√©cursive de la recherche dichotomique.
            </p>
            <p>
                Le principe de la recherche dichotomique consiste √† comparer la valeur recherch√©e avec la valeur centrale de la liste afin d'√©liminer la moiti√© des valeurs o√π ne peut pas se trouver la valeur recherch√©e.
            </p>
            <div class="exercice">
                <ol>
                    <li>Dans une liste de <mark class="code">n</mark> √©l√©ments, quel est l'indice de l'√©l√©ment central ?</li>
                    <li>Si la valeur recherch√©e est plus grande que la valeur centrale, quelle partie de la liste faut-il √©liminer ?</li>
                    <li>Quelle est la condition d'arr√™t de la r√©cursivit√© ?</li>
                    <li>Ecrire la pile d'ex√©cution lors de l'appel de : <br/> <mark class="code">recherche_dichotomique([12, 13, 15, 17, 21, 22, 22], 15)</mark></li>
                    <li>Ecrire la pile d'ex√©cution lors de l'appel de : <br/> <mark class="code">recherche_dichotomique([0, 1, 1, 2, 3, 5, 8, 13, 21], 7)</mark></li>
                    <li>Programmer la recherche dichotomique de mani√®re r√©cursive.</li>
                </ol>
            </div>
            <h3>Rendu du monnaie</h3>
            <p>
                En classe de premi√®re, nous avons vu un algorithme de rendu de monnaie.
                Cet algorithme √©tait dit <mark>glouton</mark> car il √©tait bas√© sur des choix qui paraissaient optimaux √† chaque √©tape, mais ne garantissait pas que le r√©sultat global √©tait optimal.
                Une solution pour trouver le rendu optimal serai de d√©terminer toutes les solutions de rendu de monnaie possible.
            </p>
            <p>
                Nous allons √©crire un algorithme r√©cursif qui permet de dresser cette liste.<br/>
                On suppose que le montant √† rendre et un nombre entier, tout comme le montant des pi√®ces et des billets.<br/>
                On suppose √©galement que l'on dispose de toutes les pi√®ces et billets en quantit√© illimit√©e.<br/>
                La liste des pi√®ces et billets disponibles est : <mark class="code">[500, 200, 100, 50, 20, 10, 5, 2, 1]</mark><br/>
                Par la suite, on parlera uniquement de pi√®ces pour simplifier les explications.
            </p>
            <p>
                Le principe est le suivant :
                <ul>
                    <li>
                        si le montant est sup√©rieur ou √©gal √† la valeur de la premi√®re pi√®ce, alors deux choix s'offrent √† moi :
                        <ul>
                            <li>j'utilise cette pi√®ce et je cherche √† rendre une montant plus petit avec les m√™mes pi√®ces disponibles.</li>
                            <li>je n'utilise pas cette pi√®ce et je cherche √† rendre le m√™me montant avec les autres pi√®ces disponibles.</li>
                        </ul>
                    </li>
                    <li>si le montant est inf√©rieur √† la valeur de la premi√®re pi√®ce, alors je cherche √† rendre le m√™me montant avec les autres pi√®ces disponibles.</li>
                </ul>
            </p>
            <div class="exercice">
                <ol>
                    <li>Quelles sont les conditions d'arr√™ts ?</li>
                    <li>Parmi les conditions d'arr√™ts, laquelle aboutit √† un rendu de monnaie possible ?</li>
                    <li>Ecrire la pile d'ex√©cution pour rendre 6 euros avec la liste de pi√®ces et de billets disponibles ci-dessus.</li>
                    <li>Programmer de mani√®re r√©cursive le programme affichant les rendus de monnaie possible.</li>
                </ol>
            </div>
            <h3>Suite de Fibonacci</h3>
            <h3>Tour de Hano√Ø</h3>
            <h2>Autres exercices</h2>
            <ol>
                <li><a href="miroir.html">miroir d'un mot</a></li>
                <li><a href="syracuse.html">suite de Syracuse</a></li>
                <li><a href="coefficientsBinomiaux.html">coefficients binomiaux</a></li>
                <li><a href="permutations.html">liste des permutations (et anagrammes)</a></li>
                <li><a href="jeuDame.html">jeu de la dame</a></li>
            </ol>
        </div>
        <script type="text/javascript" src="script.js"></script>
    </body>
</html>
